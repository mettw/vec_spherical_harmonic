function [Yln, Mx,My,Mz, Mav, Nx, Ny, Nz, Nav, x,y,z] = vec_spherical_harmonic(l, m, is_even, num_steps, do_plots, on_sphere)
   % This function generates the vector spherical harmonics as defined in 
   %
   % C. F. Bohren and D. R. Huffman, Absorption and scattering of light 
   % by small particles. (Wiley, 1983)
   %
   % One difference is that in this book the spherical harmonic is
   % multiplied by one of the four spherical bessel functions as a function
   % of r.  In this function on the other hand the value of the function is
   % constant along r - that is, I have used the standard spherical
   % harmonics as the scalar function to generate the vector spherical
   % harmonics.
   %
   % Arguments:
   %    l         degree of the spherical harmonic
   %    m         order of the spherical harmonic
   %    is_even   Whether or not the harmonic is even of odd.  That is,
   %              whether the scalar spherical harmonic has a cosine or
   %              sine dependence for phi.
   %    num_steps number of intervals to use in meshing.
   %    do_plots  Whether or not to generate plots.
   %
   % Outputs:
   %    Ymn       The scalar spherical harmonic defined over a cubical
   %              region of space.
   %    Mx,My,Mz  The M vector
   %    Mav       The angular velocity of M as generated by curl()
   %    Nx,Ny,Nz  The N vector
   %    Nav       The angular velocity of N as generated by curl()
   %    x,y,z     coordinates of the cubical region of space.
   %
   % NB:
   % I have used the mathematical convention with spherical coordinates 
   % where theta is the ascension and phi the azimuth.  I refer to `rho' 
   % as `r' though.
   %
   % Some of this code was taken from Daniel Ennis' spharm.m function,
   % which is copyright (c) 2009, Daniel Ennis, under the BSD 2-clause
   % license. 
   
   
    % The default size of the vectors is too small to make sense of the
    % plots.
    arrow_scale = 6;

    % Define constants (REQUIRED THAT L(DEGREE)>=M(ORDER))
    if nargin==0
      l=3;   % DEGREE
      m=2;   % ORDER
      is_even = true;
      num_steps = 25;
      do_plots = true;
      on_sphere = true;
    end
    
    if nargin<2
      m=1;   % Mie resonance
      is_even = true;
      num_steps = 25;
      do_plots = true;
      on_sphere = true;
    end

    if nargin<3
      is_even = true;
      num_steps = 25;  
      do_plots = true;
      on_sphere = true;
    end

    if nargin<4
      num_steps = 25;
      do_plots = true;
      on_sphere = true;
    end

    if nargin<5
      do_plots = true;
      on_sphere = true;
    end
    
    if l<0, error('The DEGREE (l) must be greater than zero.'); end
    if l<m, error('The ORDER (m) must be less than or eqaul to the DEGREE (l).'); end

    % theta and phi values over a sphere.
    theta = 0:pi/(2*num_steps):pi;
    phi = 0:pi/num_steps:2*pi;
    
    % Cartesian coordianates of a sphere.
    xs = sin(theta).*cos(phi)';
    ys = sin(theta).*sin(phi)';
    zs = cos(theta).*ones(size(phi))';
    
    % Square region of space from -1 to 1 in all dimensions
    [x, y, z] = meshgrid(-1:2/num_steps:1,-1:2/num_steps:1,-1:2/num_steps:1);

    % Theta and Phi through the 3D volume of space
    [Phi, Theta] = cart2sph(x,y,z); 
    
    Lln=legendre(l,cos(Theta+pi/2));

    if l~=0
      Lln=squeeze(Lln(m+1,:,:,:));
    end

    a1=((2*l+1)/(4*pi));
    a2=factorial(l-m)/factorial(l+m);
    C=sqrt(a1*a2);
    if is_even
        Yln=C*Lln.*cos(m*Phi);
    else
        Yln=C*Lln.*sin(m*Phi);
    end

    Ylns = plot_Ylm();
 
    [Mxs, Mys, Mzs] = plot_Mlm();

    [Nxs, Nys, Nzs] = plot_Nlm();
    
    if do_plots
        plot_Mlm_Nlm();
    end
    
    %%

    function Ylns = plot_Ylm()
        % plot the spherical harmonic.
        Ylns = interp3(x,y,z,Yln,xs,ys,zs);
        %[Xr,Yr,Zr]=sph2cart(Phi2,Theta2-pi/2,real(Ymns).^2);
        if do_plots
            figure;
            subplot(2,2,1);
            surf(xs.*real(Ylns).^2,ys.*real(Ylns).^2,zs.*real(Ylns).^2, real(Ylns),...
                    'EdgeColor', 'flat', 'FaceColor','interp');
            set_pbaspect();
            if is_even
                title_str = sprintf('Y_%d^{%d,c}', l, m);
            else
                title_str = sprintf('Y_%d^{%d,s}', l, m);
            end
            title(title_str);
        end
    end

%%

    function [Mxs, Mys, Mzs] = plot_Mlm()
        % Calculate the vector spherical harmonic M=curl rPhi
        [Mx, My, Mz, Mav] = curl(x,y,z,x.*Yln,y.*Yln,z.*Yln);
        
        % Get vector components over the unit sphere
        Mxs = interp3(x,y,z,Mx,xs,ys,zs);
        Mys = interp3(x,y,z,My,xs,ys,zs);
        Mzs = interp3(x,y,z,Mz,xs,ys,zs);

        if do_plots
            subplot(2,2,3);
            quiver3(xs,ys,zs, Mxs,Mys,Mzs, arrow_scale, 'Color', 'black');
            pbaspect([1 1 1]);

            if is_even
                title_str = sprintf('M_{e,%d,%d}', l, m);
            else
                title_str = sprintf('M_{o,%d,%d}', l, m);
            end
            title(title_str);

            hold on;
            surf(xs,ys,zs, real(Ylns),...
                    'EdgeColor', 'interp', 'FaceColor','none');
            hold off;
        end
    end
    %%

    function [Nxs, Nys, Nzs] = plot_Nlm()
        % Calculate the vector spherical harmonic N=(curl M)/k
        [Nx, Ny, Nz, Nav] = curl(x,y,z,Mx, My, Mz);
        
        % Supposed to be dividing by k here, but since we are using
        % spherical harmonics instead of the proper function, we just set
        % the wavelength to 1.
        Nx = Nx/(2*pi);
        Ny = Ny/(2*pi);
        Nz = Nz/(2*pi);
        
        % Get vector components over the unit sphere
        Nxs = interp3(x,y,z,Nx,xs,ys,zs);
        Nys = interp3(x,y,z,Ny,xs,ys,zs);
        Nzs = interp3(x,y,z,Nz,xs,ys,zs);

        if do_plots
            subplot(2,2,4);
            quiver3(xs,ys,zs, Nxs,Nys,Nzs, arrow_scale, 'Color', 'black');
            pbaspect([1 1 1]);

            if is_even
                title_str = sprintf('N_{e,%d,%d}', l, m);
            else
                title_str = sprintf('N_{o,%d,%d}', l, m);
            end
            title(title_str);

            hold on;
            surf(xs,ys,zs, real(Ylns),...
                    'EdgeColor', 'interp', 'FaceColor','none');
            hold off;
        end
    end
       %%

    function plot_Mlm_Nlm()
        % plot Mlm + Nlm
        subplot(2,2,2);
        if on_sphere
            quiver3(xs,ys,zs, Mxs + Nxs,Mys + Nys,Mzs + Nzs,...
                arrow_scale, 'Color', 'black');
            pbaspect([1 1 1]);
        else
            quiver3(xs.*real(Ylns).^2,ys.*real(Ylns).^2,zs.*real(Ylns).^2, Mxs + Nxs,Mys + Nys,Mzs + Nzs,...
                arrow_scale, 'Color', 'black');
            set_pbaspect();
        end
        
        if is_even
            title_str = sprintf('M_{e,%d,%d} + N_{e,%d,%d}', l, m, l, m);
        else
            title_str = sprintf('M_{o,%d,%d} + N_{o,%d,%d}', l, m, l, m);
        end
        title(title_str);

        hold on;
        if on_sphere
            surf(xs,ys,zs, real(Ylns),...
                    'EdgeColor', 'interp', 'FaceColor','none');
        else
            surf(xs.*real(Ylns).^2,ys.*real(Ylns).^2,zs.*real(Ylns).^2, real(Ylns),...
                    'EdgeColor', 'interp', 'FaceColor','none');
        end
        hold off;
    end
%%    
    function set_pbaspect()
        % Sets the axes of the spherical harmonic plot so that each axis
        % has the same scale.  ie, none of the axes are cramped.
        switch l
            case 0
                pba = [1 1 1];
            case 1
                switch m
                    case -1
                        pba = [2 1 1];
                    case 0
                        pba = [1 1 2];
                    case 1
                        pba = [2 1 1];
                end
            case 2
                switch m
                    case -2
                        pba = [3 3 1];
                    case -1
                        pba = [3 1 3];
                    case 0
                        pba = [1 1 4];
                    case 1
                        pba = [3 1 3];
                    case 2
                        pba = [3 3 1];
                end
            case 3
                switch m
                    case -3
                        pba = [4 4 1];
                    case -2
                        pba = [3 3 2];
                    case -1
                        pba = [3 1 4];
                    case 0
                        pba = [1 1 6];
                    case 1
                        pba = [3 1 4];
                    case 2
                        pba = [3 3 2];
                    case 3
                        pba = [4 4 1];
                end
        end
        if l<=3
            pbaspect(pba);
        end
    end
end