classdef MSphHarmonic < handle
    % MphHarmonic - M Vector Spherical Harmonics
    %
    % 
    
    %properties (GetAccess='private', SetAccess='private')
    properties (SetAccess='private')
        % Parent object
        parent;
        
        %    Mx,My,Mz  The M vector over a cube of space
        Mx;
        My;
        Mz;
        %    and over the surface of a sphere
        Mx_sph;
        My_sph;
        Mz_sph;
        %    Mav       The angular velocity of M as generated by curl()
        Mav;
        %    Mangx,
        %    Mangy,
        %    Mangz     The phi and theta components of M only.
        %    Mang      Absolute value of above
        Mangx;
        Mangy;
        Mangz;
        Mang;
        
    end
    
    methods
        %
        % SETUP functions
        %
        
        function hObj = MSphHarmonic(parent)
        
            hObj.parent = parent;
            % Calculate the vector spherical harmonic M=curl rPhi
            %{
            [hObj.Mx, hObj.My, hObj.Mz, hObj.Mav] = ...
                curl(hObj.parent.x, hObj.parent.y, hObj.parent.z, ...
                hObj.parent.x.*hObj.parent.Yln, hObj.parent.y.*hObj.parent.Yln, hObj.parent.z.*hObj.parent.Yln);
            %}
            % {
            [grad_x, grad_y, grad_z] = gradient(hObj.parent.Yln, 2/hObj.parent.num_steps);
            hObj.Mx = hObj.parent.y.*grad_z - hObj.parent.z.*grad_y;
            hObj.My = -(hObj.parent.x.*grad_z - hObj.parent.z.*grad_x);
            hObj.Mz = hObj.parent.x.*grad_y - hObj.parent.y.*grad_x;
            hObj.Mx = hObj.Mx/sqrt(hObj.parent.l*(hObj.parent.l+1));%1i;
            hObj.My = hObj.My/sqrt(hObj.parent.l*(hObj.parent.l+1));%1i;
            hObj.Mz = hObj.Mz/sqrt(hObj.parent.l*(hObj.parent.l+1));%1i;
            %}
            % Get vector components over the unit sphere
            hObj.Mx_sph = interp3(hObj.parent.x, hObj.parent.y, hObj.parent.z, ...
                hObj.Mx, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);
            hObj.My_sph = interp3(hObj.parent.x, hObj.parent.y, hObj.parent.z, ...
                hObj.My, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);
            hObj.Mz_sph = interp3(hObj.parent.x, hObj.parent.y, hObj.parent.z, ...
                hObj.Mz, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);
            
            % Need to take the cross product of MN with the unit
            % radial vector.
            hObj.Mangx = hObj.parent.y.*hObj.Mz - hObj.parent.z.*hObj.My;
            hObj.Mangy = -(hObj.parent.x.*hObj.Mz - hObj.parent.z.*hObj.Mx);
            hObj.Mangz = hObj.parent.x.*hObj.My - hObj.parent.y.*hObj.Mx;
            
            % Get vector components over the unit sphere
            hObj.Mangx = interp3(hObj.parent.x, hObj.parent.y, hObj.parent.z,...
                hObj.Mangx, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);
            hObj.Mangy = interp3(hObj.parent.x, hObj.parent.y, hObj.parent.z,...
                hObj.Mangy, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);
            hObj.Mangz = interp3(hObj.parent. x,hObj.parent.y, hObj.parent.z,...
                hObj.Mangz, hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph);

            hObj.Mang = sqrt(hObj.Mangx.^2 + hObj.Mangy.^2 + hObj.Mangz.^2);
        
        end
        
        %% 
        %
        % PLOTTING functions
        %
        
        function plot_ang(hObj)
            figure;
%{
            surf(hObj.parent.x_sph.*real(hObj.Mang), hObj.parent.y_sph.*real(hObj.Mang), ...
                hObj.parent.z_sph.*real(hObj.Mang), real(hObj.Mang),...
                'EdgeColor', 'flat', 'FaceColor','interp');
            %}
            surf(hObj.parent.x_sph.*imag(hObj.Mang), hObj.parent.y_sph.*imag(hObj.Mang), ...
                hObj.parent.z_sph.*imag(hObj.Mang), real(hObj.Mang),...
                'EdgeColor', 'flat', 'FaceColor','interp');
            switch hObj.parent.parity 
                case Parity.Even
                    title_str = sprintf('$$|\\mathrm{(r/|r|)\\times M^e_{%d,%d}}|$$', hObj.parent.l, hObj.parent.m);
                case Parity.Odd
                    title_str = sprintf('$$|\\mathrm{(r/|r|)\\times M^o_{%d,%d}}|$$', hObj.parent.l, hObj.parent.m);
                otherwise
                    title_str = sprintf('$$|\\mathrm{(r/|r|)\\times M_{%d,%d}}|$$', hObj.parent.l, hObj.parent.m);
            end
            title(title_str,'Interpreter','latex');
            xlabel('x');
            ylabel('y');
            zlabel('z');
            colormap jet;
        end
        
        function plot_ang_vec(hObj)
            figure;

            quiver3(hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph, ...
                real(hObj.Mangx), real(hObj.Mangy), real(hObj.Mangz), 3,...hObj.parent.arrow_scale,...
                'Color', 'black', 'LineWidth', 2);
            pbaspect([1 1 1]);
            switch hObj.parent.parity 
                case Parity.Even
                    title_str = sprintf('$$\\mathrm{(r/|r|)\\times M^e_{%d,%d}}$$', hObj.parent.l, hObj.parent.m);
                case Parity.Odd
                    title_str = sprintf('$$\\mathrm{(r/|r|)\\times M^o_{%d,%d}}$$', hObj.parent.l, hObj.parent.m);
                otherwise
                    title_str = sprintf('$$\\mathrm{(r/|r|)\\times M_{%d,%d}}$$', hObj.parent.l, hObj.parent.m);
            end
            title(title_str,'Interpreter','latex');
            xlabel('x');
            ylabel('y');
            zlabel('z');
            hold on;
            %surf(hObj.parent.x_sph, hObj.parent.y_sph, hObj.parent.z_sph, real(hObj.parent.Yln_sph),...
            %        'EdgeColor', 'interp', 'FaceColor','none');
            hold off;
            colormap jet;
        end
        
        function plot_ang_abs_vec(hObj)
            figure;
            
            % The vector field is the real parts of M, so we want the
            % absolute value of the real parts of the vectors.
            abs_vec = sqrt(real(hObj.Mangx).^2 + real(hObj.Mangy).^2 + real(hObj.Mangz).^2);
            surf(hObj.parent.x_sph.*abs_vec, hObj.parent.y_sph.*abs_vec, hObj.parent.z_sph.*abs_vec,...
                abs_vec, 'EdgeColor', 'flat', 'FaceColor','interp');
            
            pbaspect([1 1 1]);
            %hObj.set_pbaspect2;
            switch hObj.parent.parity 
                case Parity.Even
                    title_str = sprintf('$$\\mathrm{|(r/|r|)\\times M^e_{%d,%d}|}$$', hObj.parent.l, hObj.parent.m);
                case Parity.Odd
                    title_str = sprintf('$$\\mathrm{|(r/|r|)\\times M^o_{%d,%d}|}$$', hObj.parent.l, hObj.parent.m);
                otherwise
                    title_str = sprintf('$$\\mathrm{|(r/|r|)\\times M_{%d,%d}|}$$', hObj.parent.l, hObj.parent.m);
            end
            %title(title_str,'Interpreter','latex');
            xlabel('x');
            ylabel('y');
            zlabel('z');
            colormap jet;
        end
        
        %% 
        %
        % SUNDRY functions
        %

        function set_pbaspect(hObj)
            % Sets the axes of the spherical harmonic plot so that each axis
            % has the same scale.  ie, none of the axes are cramped.
            switch hObj.parent.l
                case 0
                    pba = [1 1 1];
                case 1
                    switch hObj.parent.m
                        case -1
                            pba = [2 1 1];
                        case 0
                            pba = [1 1 2];
                        case 1
                            pba = [2 1 1];
                    end
                case 2
                    switch hObj.parent.m
                        case -2
                            pba = [3 3 1];
                        case -1
                            pba = [3 1 3];
                        case 0
                            pba = [1 1 4];
                        case 1
                            pba = [3 1 3];
                        case 2
                            pba = [3 3 1];
                    end
                case 3
                    switch hObj.parent.m
                        case -3
                            pba = [4 4 1];
                        case -2
                            pba = [3 3 2];
                        case -1
                            pba = [3 1 4];
                        case 0
                            pba = [1 1 6];
                        case 1
                            pba = [3 1 4];
                        case 2
                            pba = [3 3 2];
                        case 3
                            pba = [4 4 1];
                    end
                otherwise
                    pba = [1 1 1];
            end
            if hObj.parent.l<=3
                pbaspect(pba);
            end
        end
    end
end

